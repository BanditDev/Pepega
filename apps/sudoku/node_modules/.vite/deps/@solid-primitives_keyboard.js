import "./chunk-CK2PXRSK.js";
import {
  batch,
  createEffect,
  createMemo,
  createRoot,
  createSignal,
  getOwner,
  on,
  onCleanup,
  untrack
} from "./chunk-JCYINQJ6.js";

// node_modules/@solid-primitives/utils/dist/index.js
var arrayEquals = (a, b) => a === b || a.length === b.length && a.every((e, i) => e === b[i]);

// node_modules/@solid-primitives/event-listener/dist/index.js
function makeEventListener(target, type, handler, options) {
  target.addEventListener(type, handler, options);
  return onCleanup(target.removeEventListener.bind(target, type, handler, options));
}

// node_modules/@solid-primitives/rootless/dist/index.js
function createSharedRoot(factory) {
  let listeners = 0;
  let value;
  let dispose;
  return () => {
    if (!dispose) {
      createRoot((_dispose) => {
        value = factory(_dispose);
        dispose = _dispose;
      });
    }
    listeners++;
    getOwner() && onCleanup(() => {
      listeners--;
      queueMicrotask(() => {
        if (listeners || !dispose)
          return;
        dispose();
        dispose = void 0;
        value = void 0;
      });
    });
    return value;
  };
}

// node_modules/@solid-primitives/keyboard/dist/index.js
function equalsKeyHoldSequence(sequence, model) {
  for (let i = sequence.length - 1; i >= 0; i--) {
    const _model = model.slice(0, i + 1);
    if (!arrayEquals(sequence[i], _model))
      return false;
  }
  return true;
}
var useKeyDownList = createSharedRoot(() => {
  const [pressedKeys, setPressedKeys] = createSignal([]);
  const [event, setEvent] = createSignal(null);
  const reset = () => setPressedKeys([]);
  makeEventListener(window, "keydown", (e) => {
    if (e.repeat)
      return;
    const key = e.key.toUpperCase();
    if (pressedKeys().includes(key))
      return;
    batch(() => {
      setEvent(e);
      setPressedKeys((prev) => [...prev, key]);
    });
  });
  makeEventListener(window, "keyup", (e) => {
    const key = e.key.toUpperCase();
    setPressedKeys((prev) => prev.filter((_key) => _key !== key));
  });
  makeEventListener(window, "blur", reset);
  makeEventListener(window, "contextmenu", (e) => {
    e.defaultPrevented || reset();
  });
  return [pressedKeys, { event }];
});
var useCurrentlyHeldKey = createSharedRoot(() => {
  const [keys2] = useKeyDownList();
  let prevKeys = untrack(keys2);
  return createMemo(() => {
    const _keys = keys2();
    const prev = prevKeys;
    prevKeys = _keys;
    if (prev.length === 0 && _keys.length === 1)
      return _keys[0];
    return null;
  });
});
var useKeyDownSequence = createSharedRoot(() => {
  const [keys2] = useKeyDownList();
  return createMemo((prev) => {
    if (keys2().length === 0)
      return [];
    return [...prev, keys2()];
  }, []);
});
function createKeyHold(key, options = {}) {
  key = key.toUpperCase();
  const { preventDefault = true } = options;
  const [, { event }] = useKeyDownList();
  const heldKey = useCurrentlyHeldKey();
  return createMemo(() => {
    if (heldKey() === key) {
      preventDefault && event().preventDefault();
      return true;
    }
    return false;
  });
}
function createShortcut(keys2, callback, options = {}) {
  if (!keys2.length)
    return;
  keys2 = keys2.map((key) => key.toUpperCase());
  const { preventDefault = true, requireReset = false } = options;
  const [, { event }] = useKeyDownList();
  const sequence = useKeyDownSequence();
  let reset = false;
  const handleSequenceWithReset = (sequence2) => {
    if (!sequence2.length)
      return reset = false;
    if (reset)
      return;
    if (sequence2.length < keys2.length) {
      if (equalsKeyHoldSequence(sequence2, keys2.slice(0, sequence2.length))) {
        preventDefault && event().preventDefault();
      } else {
        reset = true;
      }
    } else {
      reset = true;
      if (equalsKeyHoldSequence(sequence2, keys2)) {
        preventDefault && event().preventDefault();
        callback();
      }
    }
  };
  const handleSequenceWithoutReset = (sequence2) => {
    const last = sequence2.at(-1);
    if (!last)
      return;
    if (preventDefault && last.length < keys2.length) {
      if (arrayEquals(last, keys2.slice(0, keys2.length - 1))) {
        event().preventDefault();
      }
      return;
    }
    if (arrayEquals(last, keys2)) {
      const prev = sequence2.at(-2);
      if (!prev || arrayEquals(prev, keys2.slice(0, keys2.length - 1))) {
        preventDefault && event().preventDefault();
        callback();
      }
    }
  };
  createEffect(on(sequence, requireReset ? handleSequenceWithReset : handleSequenceWithoutReset));
}
export {
  createKeyHold,
  createShortcut,
  useCurrentlyHeldKey,
  useKeyDownList,
  useKeyDownSequence
};
//# sourceMappingURL=@solid-primitives_keyboard.js.map
