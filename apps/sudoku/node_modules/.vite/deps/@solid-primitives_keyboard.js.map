{
  "version": 3,
  "sources": ["../../../../../node_modules/@solid-primitives/utils/dist/index.js", "../../../../../node_modules/@solid-primitives/event-listener/dist/index.js", "../../../../../node_modules/@solid-primitives/rootless/dist/index.js", "../../../../../node_modules/@solid-primitives/keyboard/dist/index.js"],
  "sourcesContent": ["\"use strict\";\n\n// src/index.ts\nimport {\n  getOwner,\n  onCleanup,\n  createSignal,\n  DEV,\n  untrack,\n  batch,\n  getListener\n} from \"solid-js\";\nimport { isServer as _isServer } from \"solid-js/web\";\nvar noop = () => void 0;\nvar isServer = _isServer;\nvar isClient = !isServer;\nvar isDev = DEV && isClient;\nvar isProd = !isDev;\nvar warn = (...a) => isDev && console.warn(...a);\nvar ofClass = (v, c) => v instanceof c || v && v.constructor === c;\nfunction isObject(value) {\n  return value !== null && (typeof value === \"object\" || typeof value === \"function\");\n}\nvar compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;\nvar arrayEquals = (a, b) => a === b || a.length === b.length && a.every((e, i) => e === b[i]);\nfunction chain(callbacks) {\n  return (...args) => {\n    for (const callback of callbacks) {\n      if (typeof callback === \"function\")\n        callback(...args);\n    }\n  };\n}\nvar clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nvar access = (v) => typeof v === \"function\" && !v.length ? v() : v;\nvar asArray = (value) => Array.isArray(value) ? value : [value];\nvar accessArray = (list) => list.map((v) => access(v));\nvar withAccess = (value, fn) => {\n  const _value = access(value);\n  typeof _value !== \"undefined\" && _value !== null && fn(_value);\n};\nvar asAccessor = (v) => typeof v === \"function\" ? v : () => v;\nfunction accessWith(valueOrFn, ...args) {\n  return typeof valueOrFn === \"function\" ? valueOrFn(...args) : valueOrFn;\n}\nfunction forEachEntry(object, iterator) {\n  Object.entries(object).forEach(([key, item], index, pairs) => iterator(key, item, index, pairs, object));\n}\nvar entries = Object.entries;\nvar keys = Object.keys;\nvar onRootCleanup = (fn) => getOwner() ? onCleanup(fn) : fn;\nvar createCallbackStack = () => {\n  let stack = [];\n  const clear = () => stack = [];\n  return {\n    push: (...callbacks) => stack.push(...callbacks),\n    execute(arg0, arg1, arg2, arg3) {\n      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));\n      clear();\n    },\n    clear\n  };\n};\nfunction createMicrotask(fn) {\n  let calls = 0;\n  let args;\n  return (...a) => {\n    args = a, calls++;\n    queueMicrotask(() => --calls === 0 && fn(...args));\n  };\n}\nfunction createProxy(traps) {\n  return new Proxy({}, {\n    get: (_, k) => traps.get(k),\n    set: (_, k, v) => {\n      var _a;\n      (_a = traps.set) == null ? void 0 : _a.call(traps, k, v);\n      return false;\n    }\n  });\n}\nvar createTrigger = isDev ? () => createSignal(void 0, { equals: false, name: \"trigger\" }) : () => createSignal(void 0, { equals: false });\nfunction dirtyTriggerCache(key) {\n  const trigger = this.get(key);\n  if (trigger)\n    trigger[1]();\n}\nfunction dirtyAllTriggerCache() {\n  this.forEach((s) => s[1]());\n}\nfunction trackTriggerCache(key) {\n  if (!getListener())\n    return;\n  let trigger = this.get(key);\n  if (!trigger) {\n    trigger = createTrigger();\n    this.set(key, trigger);\n  }\n  trigger[0]();\n}\nfunction createTriggerCache() {\n  const cache = /* @__PURE__ */ new Map();\n  return {\n    dirty: dirtyTriggerCache.bind(cache),\n    dirtyAll: dirtyAllTriggerCache.bind(cache),\n    track: trackTriggerCache.bind(cache)\n  };\n}\nfunction createWeakTriggerCache() {\n  const cache = /* @__PURE__ */ new WeakMap();\n  return {\n    dirty: dirtyTriggerCache.bind(cache),\n    track: trackTriggerCache.bind(cache)\n  };\n}\nfunction createStaticStore(init) {\n  const copy = { ...init };\n  const store = {};\n  const cache = /* @__PURE__ */ new Map();\n  const getValue = (key) => {\n    const saved = cache.get(key);\n    if (saved)\n      return saved[0]();\n    const signal = createSignal(copy[key], {\n      name: typeof key === \"string\" ? key : void 0\n    });\n    cache.set(key, signal);\n    delete copy[key];\n    return signal[0]();\n  };\n  const setValue = (key, value) => {\n    const saved = cache.get(key);\n    if (saved)\n      return saved[1](value);\n    if (key in copy)\n      copy[key] = accessWith(value, [copy[key]]);\n  };\n  for (const key of keys(init)) {\n    store[key] = void 0;\n    Object.defineProperty(store, key, {\n      get: getValue.bind(void 0, key)\n    });\n  }\n  const setter = (a, b) => {\n    if (isObject(a))\n      untrack(() => {\n        batch(() => {\n          for (const [key, value] of entries(accessWith(a, store)))\n            setValue(key, () => value);\n        });\n      });\n    else\n      setValue(a, b);\n    return store;\n  };\n  return [store, setter];\n}\nfunction handleDiffArray(current, prev, handleAdded, handleRemoved) {\n  const currLength = current.length;\n  const prevLength = prev.length;\n  let i = 0;\n  if (!prevLength) {\n    for (; i < currLength; i++)\n      handleAdded(current[i]);\n    return;\n  }\n  if (!currLength) {\n    for (; i < prevLength; i++)\n      handleRemoved(prev[i]);\n    return;\n  }\n  for (; i < prevLength; i++) {\n    if (prev[i] !== current[i])\n      break;\n  }\n  let prevEl;\n  let currEl;\n  prev = prev.slice(i);\n  current = current.slice(i);\n  for (prevEl of prev) {\n    if (!current.includes(prevEl))\n      handleRemoved(prevEl);\n  }\n  for (currEl of current) {\n    if (!prev.includes(currEl))\n      handleAdded(currEl);\n  }\n}\nexport {\n  access,\n  accessArray,\n  accessWith,\n  arrayEquals,\n  asAccessor,\n  asArray,\n  chain,\n  clamp,\n  compare,\n  createCallbackStack,\n  createMicrotask,\n  createProxy,\n  createStaticStore,\n  createTrigger,\n  createTriggerCache,\n  createWeakTriggerCache,\n  entries,\n  forEachEntry,\n  handleDiffArray,\n  isClient,\n  isDev,\n  isObject,\n  isProd,\n  isServer,\n  keys,\n  noop,\n  ofClass,\n  onRootCleanup,\n  warn,\n  withAccess\n};\n", "// src/eventListener.ts\nimport { isServer, access, asArray } from \"@solid-primitives/utils\";\nimport { createEffect, onCleanup, createRenderEffect, createSignal } from \"solid-js\";\nfunction makeEventListener(target, type, handler, options) {\n  target.addEventListener(type, handler, options);\n  return onCleanup(target.removeEventListener.bind(target, type, handler, options));\n}\nfunction createEventListener(targets, type, handler, options) {\n  if (isServer)\n    return;\n  const attachListeners = () => {\n    asArray(access(targets)).forEach((el) => {\n      if (el)\n        asArray(access(type)).forEach((type2) => makeEventListener(el, type2, handler, options));\n    });\n  };\n  if (typeof targets === \"function\")\n    createEffect(attachListeners);\n  else\n    createRenderEffect(attachListeners);\n}\nfunction createEventSignal(target, type, options) {\n  const [lastEvent, setLastEvent] = createSignal();\n  createEventListener(target, type, setLastEvent, options);\n  return lastEvent;\n}\nvar eventListener = (target, props) => {\n  createEffect(() => {\n    const [type, handler, options] = props();\n    makeEventListener(target, type, handler, options);\n  });\n};\n\n// src/eventListenerMap.ts\nimport { forEachEntry } from \"@solid-primitives/utils\";\nfunction createEventListenerMap(targets, handlersMap, options) {\n  forEachEntry(handlersMap, (eventName, handler) => {\n    if (handler)\n      createEventListener(targets, eventName, handler, options);\n  });\n}\n\n// src/components.ts\nimport { isClient, keys } from \"@solid-primitives/utils\";\nvar attachPropListeners = (target, props) => {\n  keys(props).forEach((attr) => {\n    if (attr.startsWith(\"on\") && typeof props[attr] === \"function\")\n      makeEventListener(target, attr.substring(2).toLowerCase(), props[attr]);\n  });\n};\nfunction WindowEventListener(props) {\n  if (isClient)\n    attachPropListeners(window, props);\n  return void 0;\n}\nfunction DocumentEventListener(props) {\n  if (isClient)\n    attachPropListeners(document, props);\n  return void 0;\n}\n\n// src/eventListenerStack.ts\nimport { createCallbackStack } from \"@solid-primitives/utils\";\nimport { onCleanup as onCleanup2 } from \"solid-js\";\nfunction makeEventListenerStack(target, options) {\n  const { push, execute } = createCallbackStack();\n  return [\n    (type, handler, overwriteOptions) => {\n      const clear = makeEventListener(target, type, handler, overwriteOptions ?? options);\n      push(clear);\n      return clear;\n    },\n    onCleanup2(execute)\n  ];\n}\n\n// src/callbackWrappers.ts\nvar preventDefault = (callback) => (e) => {\n  e.preventDefault();\n  callback(e);\n};\nvar stopPropagation = (callback) => (e) => {\n  e.stopPropagation();\n  callback(e);\n};\nvar stopImmediatePropagation = (callback) => (e) => {\n  e.stopImmediatePropagation();\n  callback(e);\n};\nexport {\n  DocumentEventListener,\n  WindowEventListener,\n  createEventListener,\n  createEventListenerMap,\n  createEventSignal,\n  eventListener,\n  makeEventListener,\n  makeEventListenerStack,\n  preventDefault,\n  stopImmediatePropagation,\n  stopPropagation\n};\n", "// src/index.ts\nimport { asArray, access } from \"@solid-primitives/utils\";\nimport { createRoot, getOwner, onCleanup, runWithOwner } from \"solid-js\";\nfunction createBranch(fn, ...owners) {\n  if (owners.length === 0)\n    owners = [getOwner()];\n  return createRoot((dispose) => {\n    asArray(access(owners)).forEach(\n      (owner) => owner && runWithOwner(owner, onCleanup.bind(void 0, dispose))\n    );\n    return fn(dispose);\n  }, owners[0] || void 0);\n}\nvar createCallback = (callback, owner = getOwner()) => owner ? (...args) => runWithOwner(owner, () => callback(...args)) : callback;\nfunction createDisposable(fn, ...owners) {\n  return createBranch((dispose) => {\n    fn(dispose);\n    return dispose;\n  }, ...owners);\n}\nfunction createSharedRoot(factory) {\n  let listeners = 0;\n  let value;\n  let dispose;\n  return () => {\n    if (!dispose) {\n      createRoot((_dispose) => {\n        value = factory(_dispose);\n        dispose = _dispose;\n      });\n    }\n    listeners++;\n    getOwner() && onCleanup(() => {\n      listeners--;\n      queueMicrotask(() => {\n        if (listeners || !dispose)\n          return;\n        dispose();\n        dispose = void 0;\n        value = void 0;\n      });\n    });\n    return value;\n  };\n}\nexport {\n  createBranch,\n  createCallback,\n  createDisposable,\n  createSharedRoot\n};\n", "// src/index.ts\nimport { makeEventListener } from \"@solid-primitives/event-listener\";\nimport { createSharedRoot } from \"@solid-primitives/rootless\";\nimport { arrayEquals } from \"@solid-primitives/utils\";\nimport { batch, createEffect, createMemo, createSignal, on, untrack } from \"solid-js\";\nfunction equalsKeyHoldSequence(sequence, model) {\n  for (let i = sequence.length - 1; i >= 0; i--) {\n    const _model = model.slice(0, i + 1);\n    if (!arrayEquals(sequence[i], _model))\n      return false;\n  }\n  return true;\n}\nvar useKeyDownList = /* @__PURE__ */ createSharedRoot(() => {\n  const [pressedKeys, setPressedKeys] = createSignal([]);\n  const [event, setEvent] = createSignal(null);\n  const reset = () => setPressedKeys([]);\n  makeEventListener(window, \"keydown\", (e) => {\n    if (e.repeat)\n      return;\n    const key = e.key.toUpperCase();\n    if (pressedKeys().includes(key))\n      return;\n    batch(() => {\n      setEvent(e);\n      setPressedKeys((prev) => [...prev, key]);\n    });\n  });\n  makeEventListener(window, \"keyup\", (e) => {\n    const key = e.key.toUpperCase();\n    setPressedKeys((prev) => prev.filter((_key) => _key !== key));\n  });\n  makeEventListener(window, \"blur\", reset);\n  makeEventListener(window, \"contextmenu\", (e) => {\n    e.defaultPrevented || reset();\n  });\n  return [pressedKeys, { event }];\n});\nvar useCurrentlyHeldKey = /* @__PURE__ */ createSharedRoot(() => {\n  const [keys] = useKeyDownList();\n  let prevKeys = untrack(keys);\n  return createMemo(() => {\n    const _keys = keys();\n    const prev = prevKeys;\n    prevKeys = _keys;\n    if (prev.length === 0 && _keys.length === 1)\n      return _keys[0];\n    return null;\n  });\n});\nvar useKeyDownSequence = /* @__PURE__ */ createSharedRoot(() => {\n  const [keys] = useKeyDownList();\n  return createMemo((prev) => {\n    if (keys().length === 0)\n      return [];\n    return [...prev, keys()];\n  }, []);\n});\nfunction createKeyHold(key, options = {}) {\n  key = key.toUpperCase();\n  const { preventDefault = true } = options;\n  const [, { event }] = useKeyDownList();\n  const heldKey = useCurrentlyHeldKey();\n  return createMemo(() => {\n    if (heldKey() === key) {\n      preventDefault && event().preventDefault();\n      return true;\n    }\n    return false;\n  });\n}\nfunction createShortcut(keys, callback, options = {}) {\n  if (!keys.length)\n    return;\n  keys = keys.map((key) => key.toUpperCase());\n  const { preventDefault = true, requireReset = false } = options;\n  const [, { event }] = useKeyDownList();\n  const sequence = useKeyDownSequence();\n  let reset = false;\n  const handleSequenceWithReset = (sequence2) => {\n    if (!sequence2.length)\n      return reset = false;\n    if (reset)\n      return;\n    if (sequence2.length < keys.length) {\n      if (equalsKeyHoldSequence(sequence2, keys.slice(0, sequence2.length))) {\n        preventDefault && event().preventDefault();\n      } else {\n        reset = true;\n      }\n    } else {\n      reset = true;\n      if (equalsKeyHoldSequence(sequence2, keys)) {\n        preventDefault && event().preventDefault();\n        callback();\n      }\n    }\n  };\n  const handleSequenceWithoutReset = (sequence2) => {\n    const last = sequence2.at(-1);\n    if (!last)\n      return;\n    if (preventDefault && last.length < keys.length) {\n      if (arrayEquals(last, keys.slice(0, keys.length - 1))) {\n        event().preventDefault();\n      }\n      return;\n    }\n    if (arrayEquals(last, keys)) {\n      const prev = sequence2.at(-2);\n      if (!prev || arrayEquals(prev, keys.slice(0, keys.length - 1))) {\n        preventDefault && event().preventDefault();\n        callback();\n      }\n    }\n  };\n  createEffect(on(sequence, requireReset ? handleSequenceWithReset : handleSequenceWithoutReset));\n}\nexport {\n  createKeyHold,\n  createShortcut,\n  useCurrentlyHeldKey,\n  useKeyDownList,\n  useKeyDownSequence\n};\n"],
  "mappings": "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",
  "names": ["keys"]
}
